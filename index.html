<!doctype html>
<html lang="en" class="h-full">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crystal Lattice Visualizer</title>
  <script src="/_sdk/element_sdk.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&amp;display=swap" rel="stylesheet">
  <style>
    body {
      box-sizing: border-box;
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    .crystal-container {
      font-family: 'Space Grotesk', sans-serif;
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #cbd5e1 100%);
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .header {
      padding: 12px 16px;
      text-align: center;
      background: rgba(255, 255, 255, 0.7);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(148, 163, 184, 0.3);
    }
    .main-title {
      font-size: 20px;
      font-weight: 700;
      color: #1e293b;
      letter-spacing: -0.5px;
    }
    .subtitle {
      font-size: 11px;
      color: #64748b;
      margin-top: 2px;
    }
    @media (min-width: 768px) {
      .header {
        padding: 16px 24px;
      }
      .main-title {
        font-size: 28px;
      }
      .subtitle {
        font-size: 14px;
        margin-top: 4px;
      }
    }
    .canvas-wrapper {
      flex: 1;
      position: relative;
      min-height: 0;
    }
    #canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    .controls {
      position: absolute;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 10px 12px;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.5);
      width: auto;
      max-width: 90vw;
    }
    .control-btn {
      padding: 8px 12px;
      border: none;
      border-radius: 8px;
      font-family: 'Space Grotesk', sans-serif;
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      white-space: nowrap;
    }
    @media (min-width: 768px) {
      .controls {
        flex-direction: row;
        bottom: 20px;
        width: auto;
        max-width: none;
        padding: 12px 20px;
        gap: 12px;
      }
      .control-btn {
        padding: 10px 18px;
        font-size: 13px;
        gap: 6px;
      }
    }
    .control-btn.primary {
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      color: white;
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }
    .control-btn.primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
    }
    .control-btn.secondary {
      background: #f1f5f9;
      color: #475569;
      border: 1px solid #e2e8f0;
    }
    .control-btn.secondary:hover {
      background: #e2e8f0;
    }
    .control-btn.active {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      border: none;
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
    }
    .labels-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    .structure-label {
      position: absolute;
      padding: 8px 14px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 10px;
      font-weight: 600;
      font-size: 13px;
      color: #1e293b;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(148, 163, 184, 0.2);
      transition: opacity 0.3s ease;
    }
    .structure-label.bcc {
      top: 12px;
      left: 15%;
      transform: translateX(-50%);
    }
    .structure-label.fcc {
      top: 12px;
      right: 15%;
      transform: translateX(50%);
    }
    .structure-label .full-name {
      font-size: 9px;
      font-weight: 400;
      color: #64748b;
      display: block;
      margin-top: 2px;
    }
    @media (min-width: 768px) {
      .structure-label {
        padding: 10px 20px;
        border-radius: 12px;
        font-size: 16px;
      }
      .structure-label.bcc {
        top: 20px;
        left: 25%;
      }
      .structure-label.fcc {
        top: 20px;
        right: 25%;
      }
      .structure-label .full-name {
        font-size: 11px;
        margin-top: 2px;
      }
    }
    .legend {
      position: absolute;
      top: 12px;
      right: 12px;
      padding: 10px 12px;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      border-radius: 10px;
      font-size: 10px;
      color: #475569;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 6px;
    }
    .legend-item:last-child {
      margin-bottom: 0;
    }
    @media (min-width: 768px) {
      .legend {
        top: 20px;
        right: 20px;
        padding: 16px;
        border-radius: 12px;
        font-size: 12px;
      }
      .legend-item {
        gap: 8px;
        margin-bottom: 8px;
      }
    }
    .legend-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }
    .legend-dot.atom {
      background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%);
      box-shadow: 0 0 8px rgba(59, 130, 246, 0.5);
    }
    .legend-dot.electron {
      background: linear-gradient(135deg, #fcd34d 0%, #f59e0b 100%);
      box-shadow: 0 0 8px rgba(245, 158, 11, 0.5);
    }
    .instructions {
      position: absolute;
      bottom: 90px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      color: #64748b;
      text-align: center;
      background: rgba(255, 255, 255, 0.8);
      padding: 6px 12px;
      border-radius: 6px;
      display: none;
    }
    @media (min-width: 768px) {
      .instructions {
        display: block;
        font-size: 12px;
        padding: 8px 16px;
        border-radius: 8px;
        bottom: 90px;
      }
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
  <script src="https://cdn.tailwindcss.com" type="text/javascript"></script>
 </head>
 <body class="h-full">
  <div class="crystal-container">
   <header class="header">
    <h1 class="main-title" id="titleText">C·∫•u tr√∫c m·∫°ng tinh th·ªÉ</h1>
    <p class="subtitle">M√¥ ph·ªèng 3D t∆∞∆°ng t√°c s·ª± s·∫Øp x·∫øp nguy√™n t·ª≠</p>
   </header>
   <div class="canvas-wrapper">
    <canvas id="canvas"></canvas>
    <div class="labels-container" id="labelsContainer">
     <div class="structure-label bcc" id="bccLabel">
      BCC <span class="full-name">L·∫≠p ph∆∞∆°ng t√¢m th√¢n</span>
     </div>
     <div class="structure-label fcc" id="fccLabel">
      FCC <span class="full-name">L·∫≠p ph∆∞∆°ng t√¢m m·∫∑t</span>
     </div>
    </div>
    <div class="legend">
     <div class="legend-item">
      <div class="legend-dot atom"></div><span>Nguy√™n t·ª≠</span>
     </div>
     <div class="legend-item">
      <div class="legend-dot electron"></div><span>ƒêi·ªán t·ª≠</span>
     </div>
    </div>
    <div class="instructions">
     üñ±Ô∏è K√©o ƒë·ªÉ quay ‚Ä¢ Cu·ªôn ƒë·ªÉ ph√≥ng to
    </div>
    <div class="controls"><button class="control-btn primary" id="autoRotateBtn"> ‚ü≥ Quay t·ª± ƒë·ªông </button> <button class="control-btn secondary" id="toggleLabelsBtn"> üè∑Ô∏è Hi·ªán nh√£n </button> <button class="control-btn secondary" id="zoomInBtn"> üîç+ Ph√≥ng to </button> <button class="control-btn secondary" id="zoomOutBtn"> üîç- Thu nh·ªè </button> <button class="control-btn secondary" id="resetBtn"> ‚Ü∫ ƒê·∫∑t l·∫°i </button>
    </div>
   </div>
  </div>
  <script>
    const defaultConfig = {
      bcc_label: 'BCC',
      fcc_label: 'FCC',
      title_text: 'C·∫•u tr√∫c m·∫°ng tinh th·ªÉ',
      primary_color: '#3b82f6',
      secondary_color: '#f59e0b',
      background_color: '#f8fafc',
      text_color: '#1e293b',
      surface_color: '#ffffff'
    };

    let config = { ...defaultConfig };

    // Three.js variables
    let scene, camera, renderer, bccGroup, fccGroup;
    let electrons = { bcc: [], fcc: [] };
    let electronTrails = { bcc: [], fcc: [] };
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let autoRotate = true;
    let showLabels = true;
    let targetRotation = { x: 0, y: 0 };
    let currentRotation = { x: 0, y: 0 };

    function init() {
      const canvas = document.getElementById('canvas');
      const container = canvas.parentElement;

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f4f8);

      camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
      camera.position.set(0, 3, 12);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 15, 10);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
      fillLight.position.set(-10, 5, -10);
      scene.add(fillLight);

      // Create structures
      bccGroup = createBCCStructure();
      bccGroup.position.x = -2;
      scene.add(bccGroup);

      fccGroup = createFCCStructure();
      fccGroup.position.x = 2;
      scene.add(fccGroup);

      // Create electrons
      createElectrons(bccGroup, 'bcc');
      createElectrons(fccGroup, 'fcc');

      // Event listeners
      setupEventListeners(canvas);

      // Start animation
      animate();
    }

    function createAtom(radius = 0.25, color = 0x3b82f6) {
      const geometry = new THREE.SphereGeometry(radius, 32, 32);
      const material = new THREE.MeshPhongMaterial({
        color: color,
        shininess: 100,
        specular: 0x444444,
        emissive: color,
        emissiveIntensity: 0.1
      });
      const sphere = new THREE.Mesh(geometry, material);
      sphere.castShadow = true;
      sphere.receiveShadow = true;
      return sphere;
    }

    function createCubeFrame(size = 2) {
      const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(size, size, size));
      const lineMaterial = new THREE.LineBasicMaterial({ 
        color: 0x94a3b8, 
        transparent: true, 
        opacity: 0.6 
      });
      return new THREE.LineSegments(edges, lineMaterial);
    }

    function createTransparentCube(size = 2) {
      const geometry = new THREE.BoxGeometry(size, size, size);
      const material = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.05,
        side: THREE.DoubleSide
      });
      return new THREE.Mesh(geometry, material);
    }

    function createBCCStructure() {
      const group = new THREE.Group();
      const cubeSize = 2;
      const halfSize = cubeSize / 2;

      // Transparent cube
      group.add(createTransparentCube(cubeSize));
      group.add(createCubeFrame(cubeSize));

      // Corner atoms
      const corners = [
        [-halfSize, -halfSize, -halfSize],
        [halfSize, -halfSize, -halfSize],
        [-halfSize, halfSize, -halfSize],
        [halfSize, halfSize, -halfSize],
        [-halfSize, -halfSize, halfSize],
        [halfSize, -halfSize, halfSize],
        [-halfSize, halfSize, halfSize],
        [halfSize, halfSize, halfSize]
      ];

      corners.forEach(pos => {
        const atom = createAtom(0.22);
        atom.position.set(...pos);
        group.add(atom);
      });

      // Body-center atom (slightly larger)
      const centerAtom = createAtom(0.28, 0x2563eb);
      centerAtom.position.set(0, 0, 0);
      group.add(centerAtom);

      return group;
    }

    function createFCCStructure() {
      const group = new THREE.Group();
      const cubeSize = 2;
      const halfSize = cubeSize / 2;

      // Transparent cube
      group.add(createTransparentCube(cubeSize));
      group.add(createCubeFrame(cubeSize));

      // Corner atoms
      const corners = [
        [-halfSize, -halfSize, -halfSize],
        [halfSize, -halfSize, -halfSize],
        [-halfSize, halfSize, -halfSize],
        [halfSize, halfSize, -halfSize],
        [-halfSize, -halfSize, halfSize],
        [halfSize, -halfSize, halfSize],
        [-halfSize, halfSize, halfSize],
        [halfSize, halfSize, halfSize]
      ];

      corners.forEach(pos => {
        const atom = createAtom(0.22);
        atom.position.set(...pos);
        group.add(atom);
      });

      // Face-center atoms
      const faceCenters = [
        [0, 0, -halfSize],
        [0, 0, halfSize],
        [0, -halfSize, 0],
        [0, halfSize, 0],
        [-halfSize, 0, 0],
        [halfSize, 0, 0]
      ];

      faceCenters.forEach(pos => {
        const atom = createAtom(0.26, 0x2563eb);
        atom.position.set(...pos);
        group.add(atom);
      });

      return group;
    }

    function createElectrons(parentGroup, type) {
      const numElectrons = 25;
      const boundarySize = 0.85;

      for (let i = 0; i < numElectrons; i++) {
        // Electron particle
        const geometry = new THREE.SphereGeometry(0.04, 16, 16);
        const material = new THREE.MeshBasicMaterial({
          color: 0xfcd34d,
          transparent: true,
          opacity: 0.9
        });
        const electron = new THREE.Mesh(geometry, material);

        // Random initial position
        electron.position.set(
          (Math.random() - 0.5) * boundarySize * 2,
          (Math.random() - 0.5) * boundarySize * 2,
          (Math.random() - 0.5) * boundarySize * 2
        );

        // Random velocity
        electron.userData.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 0.02,
          (Math.random() - 0.5) * 0.02,
          (Math.random() - 0.5) * 0.02
        );

        // Glow effect
        const glowGeometry = new THREE.SphereGeometry(0.08, 16, 16);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: 0xfcd34d,
          transparent: true,
          opacity: 0.3
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        electron.add(glow);

        parentGroup.add(electron);
        electrons[type].push(electron);

        // Trail
        const trailPositions = [];
        for (let j = 0; j < 8; j++) {
          trailPositions.push(electron.position.clone());
        }
        
        const trailGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(8 * 3);
        trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const trailMaterial = new THREE.LineBasicMaterial({
          color: 0xfcd34d,
          transparent: true,
          opacity: 0.4
        });
        
        const trail = new THREE.Line(trailGeometry, trailMaterial);
        trail.userData.positions = trailPositions;
        parentGroup.add(trail);
        electronTrails[type].push(trail);
      }
    }

    function updateElectrons(type) {
      const boundarySize = 0.9;
      const electronList = electrons[type];
      const trailList = electronTrails[type];

      electronList.forEach((electron, index) => {
        // Update position
        electron.position.add(electron.userData.velocity);

        // Elastic boundary collision
        ['x', 'y', 'z'].forEach(axis => {
          if (Math.abs(electron.position[axis]) > boundarySize) {
            electron.userData.velocity[axis] *= -1;
            electron.position[axis] = Math.sign(electron.position[axis]) * boundarySize;
          }
        });

        // Slight random movement variation
        electron.userData.velocity.x += (Math.random() - 0.5) * 0.001;
        electron.userData.velocity.y += (Math.random() - 0.5) * 0.001;
        electron.userData.velocity.z += (Math.random() - 0.5) * 0.001;

        // Limit max velocity
        const maxVel = 0.025;
        electron.userData.velocity.clampLength(0, maxVel);

        // Update trail
        const trail = trailList[index];
        trail.userData.positions.unshift(electron.position.clone());
        trail.userData.positions.pop();

        const positionAttribute = trail.geometry.attributes.position;
        trail.userData.positions.forEach((pos, i) => {
          positionAttribute.setXYZ(i, pos.x, pos.y, pos.z);
        });
        positionAttribute.needsUpdate = true;
      });
    }

    function setupEventListeners(canvas) {
      canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        previousMousePosition = { x: e.clientX, y: e.clientY };
      });

      canvas.addEventListener('mousemove', (e) => {
        if (!isDragging) return;

        const deltaX = e.clientX - previousMousePosition.x;
        const deltaY = e.clientY - previousMousePosition.y;

        targetRotation.y += deltaX * 0.005;
        targetRotation.x += deltaY * 0.005;

        previousMousePosition = { x: e.clientX, y: e.clientY };
      });

      canvas.addEventListener('mouseup', () => { isDragging = false; });
      canvas.addEventListener('mouseleave', () => { isDragging = false; });

      canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        camera.position.z += e.deltaY * 0.01;
        camera.position.z = Math.max(6, Math.min(20, camera.position.z));
      }, { passive: false });

      // Touch events
      canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
          isDragging = true;
          previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
      });

      canvas.addEventListener('touchmove', (e) => {
        if (!isDragging || e.touches.length !== 1) return;
        e.preventDefault();

        const deltaX = e.touches[0].clientX - previousMousePosition.x;
        const deltaY = e.touches[0].clientY - previousMousePosition.y;

        targetRotation.y += deltaX * 0.005;
        targetRotation.x += deltaY * 0.005;

        previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }, { passive: false });

      canvas.addEventListener('touchend', () => { isDragging = false; });

      // Control buttons
      document.getElementById('autoRotateBtn').addEventListener('click', () => {
        autoRotate = !autoRotate;
        const btn = document.getElementById('autoRotateBtn');
        btn.classList.toggle('active', autoRotate);
        btn.classList.toggle('primary', !autoRotate);
      });

      document.getElementById('toggleLabelsBtn').addEventListener('click', () => {
        showLabels = !showLabels;
        document.getElementById('labelsContainer').style.opacity = showLabels ? '1' : '0';
      });

      document.getElementById('zoomInBtn').addEventListener('click', () => {
        camera.position.z = Math.max(6, camera.position.z - 1.5);
      });

      document.getElementById('zoomOutBtn').addEventListener('click', () => {
        camera.position.z = Math.min(20, camera.position.z + 1.5);
      });

      document.getElementById('resetBtn').addEventListener('click', () => {
        targetRotation = { x: 0, y: 0 };
        camera.position.set(0, 3, 12);
      });

      // Resize handler
      window.addEventListener('resize', () => {
        const container = canvas.parentElement;
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });
    }

    function animate() {
      requestAnimationFrame(animate);

      // Auto rotation
      if (autoRotate && !isDragging) {
        targetRotation.y += 0.003;
      }

      // Smooth rotation interpolation
      currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
      currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;

      bccGroup.rotation.x = currentRotation.x;
      bccGroup.rotation.y = currentRotation.y;
      fccGroup.rotation.x = currentRotation.x;
      fccGroup.rotation.y = currentRotation.y;

      // Update electrons
      updateElectrons('bcc');
      updateElectrons('fcc');

      renderer.render(scene, camera);
    }

    function onConfigChange(newConfig) {
      config = { ...defaultConfig, ...newConfig };
      
      const titleEl = document.getElementById('titleText');
      if (titleEl) titleEl.textContent = config.title_text || defaultConfig.title_text;
      
      const bccLabelEl = document.getElementById('bccLabel');
      if (bccLabelEl) {
        const labelText = config.bcc_label || defaultConfig.bcc_label;
        bccLabelEl.innerHTML = `${labelText}<span class="full-name">Body-Centered Cubic</span>`;
      }
      
      const fccLabelEl = document.getElementById('fccLabel');
      if (fccLabelEl) {
        const labelText = config.fcc_label || defaultConfig.fcc_label;
        fccLabelEl.innerHTML = `${labelText}<span class="full-name">Face-Centered Cubic</span>`;
      }
    }

    function mapToCapabilities(cfg) {
      return {
        recolorables: [],
        borderables: [],
        fontEditable: undefined,
        fontSizeable: undefined
      };
    }

    function mapToEditPanelValues(cfg) {
      return new Map([
        ['bcc_label', cfg.bcc_label || defaultConfig.bcc_label],
        ['fcc_label', cfg.fcc_label || defaultConfig.fcc_label],
        ['title_text', cfg.title_text || defaultConfig.title_text]
      ]);
    }

    // Initialize SDK
    if (window.elementSdk) {
      window.elementSdk.init({
        defaultConfig,
        onConfigChange,
        mapToCapabilities,
        mapToEditPanelValues
      });
    }

    // Initialize visualization when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      init();
      onConfigChange(config);
    });
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9c2ed155071b77c5',t:'MTc2OTI1MDIzMC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
